# 람다 표현식이란

익명함수를 단수화한 수식. 이름은 없지만 수식에 필요한 모든 요건들을 가지고 있다.

람다는 4가지의 특징이 있다.

1. 익명: 메소드의 이름이 없다.
2. 함수: 특정 클래스에 종속되지 않는다. 그럼에도 불구하고 예외처리같은 일반 메소드가 할 수 있는 일을 제약없이 모두할 수 있다.
3. 전달: 람다 표현식을 통해 만든 함수는 변수로서 파라미터로 넘길 수 있다.
4. 간결성: 많은 조건 없이 구현체에 들어갈 내용만 적으면 된다.

람다에는 3가지 요소가 있다.

```java
(String s1, String s2) -> s1.compareTo(s2);
```

- `(String s1, String s2)` : 파라미터
- `→`: 에로우, 구분자
- `s1.compareTo(s2);` : body

# 람다의 활용 예시

## 1. 함수형 인터페이스

함수형 인터페이스는 오직 하나의 메소드만 추상화한 인터페이스를 의미한다.`Predicate<T>`, `Comparator<T>`, `Runnable` 등의 객체가 속한다.
람다를 통해 함수형 인터페이스의 구현체를 만들 수 있다. 이유는 람다표현식이 함수형 인터페이스의 객체 취급을 하기 때문이다.

<aside>
💡 단 메소드 개수에서 default 메소드는 해당하지 않는다. default 메소드가 여러개가 있더라도 추상 메소드가 하나면 함수형 인터페이스로 본다.

</aside>

## 2. 함수 디스크립터

람다 표현식의 시그니처를 서술할 수 있는 메소드를 함수 디스크립터라고 한다. 이 메소드는 어떤 파라미터를 받고, 어떤 반환타입을 가지는지를 서술한다.

```java
(String, String) -> Boolean;
(Apple, Apple) -> Integer;
```

<aside>
💡 `@FunctionalInterface`라는 새로운 어노테이션이 생겼다. 이 어노테이션의 역할은 이 인터페이스가 함수형 인터페이스임을 정의하는 역할이다. 이

</aside>

## 3. 실행 어라운드 패턴

실행 어라운드란 자바의try catch 처럼 실행하여 코드를 비워놓고 에러처리, 전처리의 코드만 있는 패턴이다.

이를 통해 공통적인 전처리를 두고 람다함수로 실행내용을 받아 전처리, 후처리를 추상화할 수 있따.

# 함수 인터페이스

람다식을 통해 표현한 함수의 파라미터 타입, 반환타입을 정의한 것을 함수 디스크립터라고 한다. 이 디스크립터도박싱, 언박싱처럼 상위타입이 하위타입까지 포함시킬 수 있다. 이를 위해 java에서는 함수형 인터페이스를 만들어 메소드 파라미터를 받을 때 이 인터페이스를 사용하도록 가이드를 해준다.

## Predicate<T>

- boolean test(T t) : 타입 t에 대한 참거짓을 판별한다.
- and, or연산을 통한 최적화가 가능하다

## Consumer<T>

- void accept(T t): 타입 t를 받아 어떤 동작을 실행한다.

## Function<T,R>

- R apply(T t) : t타입을 받고 이를 가공해 R타입 객체를 반환한다.

## 기본형 특화 함수형 인터페이스

위의 3가지 타입의 문제는 모두 객체만 가능하다. 즉 기본형 타입은 반드시 박싱된 Wrapper객체만 사용가능하다. 이는 오토박싱으로 인한 비용이 소모된다. 박싱타입은 객체이므로 heap에 저장되지만 기본형타입은 stack에 저장된다. 즉 오토박싱으로 기본타입으로 받으면 heap에 데이터를 로드하고 이를 다시 스택에 쌓는 과정을 수행해 속도가 저하된다.

# 형식검사: 같은 람다식을 다른 인터페이스로 인식시키는 방법

람다식은 같지만 이를 어디에 사용하냐에 따라 다른 인터페이스로 인식시켜 모듈화를 할 수 있다.

```java
Callable<Integer> c=()->42;
PrivilegedAction<Integer> c=()->42;
```

위의 코드는 람다식은 같지만 인터페이스 타입이 다르다. 이 일이 가능한 이유는 인터페이스이기 때문이다. 어떤 람다식을 사용하든 간에 파라미터타입, 반환 타입만 맞으면 이 인터페이스를 사용할 수 있다고 간주하기 때문이다.

이처럼 람다의 파라미터타입, 반환타입같은 표현의 형식을 가지고 기대되는 형식이 대상형식이라고 한다. 위의 코드에서는 대상 형식이 2개로 알 수 있다.

<aside>
💡 단 void 반환 람다식의 경우에는 모든 반환 파라미터가 호환된다는 특이한 규칙이 있다.

</aside>

## 형식 추론: 컴파일러가 진행하는 람다 시그니처 추론

Comparator에 넣을 람다식을 넣을 때 우린 입력하는 두 파라미터에 대해 타입을 지정하지 않는다. 함수임에도 말이다. 이것이 가능한 이유는 컴파일러가 형식을 추론하기 때문이다.

만약 특정한 타입으로 추론해야할 경우에는 람다의 파라미터에 형식을 명시할 필요가 있따.

## 캡처링: 람다에서 변수를 사용하는 방법

다른 언어에서 사용하는 ‘클로저’처럼 자바의 람다에서도 비슷한 기능을 제공한다. **람다 캡쳐링** 이라고하며 람다식 외부에 있는 변수를 캡쳐에 자유롭게 사용할 수 있다.

<aside>
💡 단 캡쳐된 변수는 final 변수이거나 실질적으로 final 변수여서 변경이 안되는 코드여야한다

</aside>

# 메소드 참조

람다식대신 특정 클래스에 있는 메소드를 사용할 때 이를 직접 호출하지 않고 레퍼런스로 참조시켜 알아서 호출시키게 한다. 이 방식은 코드의 가독성을 높인다는 이점을 가진다.