# 요약

## 단일 서버 키-값 저장소

- 단일 서버는 용이한 살계, 빠른 속도를 제공
- 모든 값이 단일 서버에 저장되어 공간의 한계가 존재
  - 이를 해결하기 위해 데이터 압축, 자주 쓰는 캐시만 메모리에 올리는 공간을 줄이는 전략이 필요

## 분산 키-값 저장소

### CAP 이론

- 일관성(Consistency), 가용성(Availability), 분산 내성(Partion Tolerance)를 모두 준수하는 DB는 불가능하다는 이론
- CA: 데이터의 일관성과 가용성을 보장(RDB)
- CP: 데이터의 일관성과 분산 내성을 보상 (MongoDB)
- AP: 데이터의 가용성과 분산 내성을 보장 (CouchDB)


## 분산 키-값 저장소에서 사용되는 핵심 컴포넌트

### 데이터 파티션

- 전체 데이터를 파티션 단위로 나누어서 여러 서버에 저장
- 주의점
    1. 특정 서버에 파티션이 몰리지 않도록 적절히 분배
    2. 서버 수가 변동될시 데이터의 이동 최소화
- 방법: 링해시를 이용한 서버 결정

### 데이터 다중화

- 데이터를 하나의 서버가 아니라 여러 서버에 분산해서 저장
- 링해시에서 가상 노드를 추가해 여러 서버에 저장하도록 가능함
  - 단 가상 노드가 가리키는 실제 서버다 모두 같지 않도록 주의해야 함

### 데이터 일관성

- 여러 서버에 데이터를 저장할 때 일관성을 보장하기 위해 주기적인 데이터의 동기화
- W: 몇 개의 서버에 쓰기 연산을 성공해야 쓰기가 성공하였다고 판단하는 기준
- R: 몇 개의 서버에 읽기 연산을 성공해야 데이터 조회가 성공하였다고 판단하는 기준
- N: 전체 서버의 대수
- W, R, N에 따라 어떤 서버가 필요할지 결정이 가능
  - W=1/R=N 혹은 W=N/R=1 : 빠른 읽기 혹은 쓰기가 필요한 시스템
  - W+R > N : 강한 일관성이 보장되어야 하는 시스템

### 데이터 버저닝(versioning)

- 데이터가 변경이 일어나는 것을 버전으로 관리
- 벡터 시계를 이용해 데이터의 변경이 동시에 발생할 때 이전 버전을 통해 충돌을 감지가 가능

### 장애 감지

- 분산 시스템에서는 여러 서버를 마치 하나의 단일 서버처럼 운용하기에 서버 하나가 죽었다고 장애가 발생하였다고 판단하기 어려움
- 여러 서버중에 하나의 서버가 장애가 발생하였으면 이를 인지하는 방법이 필요
- 가장 단순하지만 비효율인 방법: 멀티캐스팅으로 모든 서버를 연결하여 감시
- 가십 프로토콜 솔루션: 서버들의 heartbeat count를 세서 가장 오랫동안 값이 증가하지 않는 서버를 장애가 발생하였다고 판단
  - heartbeat count: 노드들이 주기적으로 증가시키는 count


### 장애 해소 방법1: 일시적 장애일 경우

- 데이터 일관성이 강한 경우: 읽기/쓰기 전체를 금지
- 데이터 일관성이 약한 경우: 건강한 서버를 기준으로 W개의 서버, R개를 선택해 데이터를 요청. 장애가 해소된 후에 장애가 발생했던 서버에게 장애 발생 기간동안 처리된 데이터들을 일괄 반영하여 해소

### 장애 해소 방법2: 영구 장애일 경우

- 반 엔트로피(anti-entropy) 프로토콜: Merkle tree를 이용하여 일관성이 깨지는 상황을 파악하여 최신본으로 갱신
- 로직
    1. 각 서버에 동일한 데이터가 저장된 상태부터 시작
    2. 데이터를 기반으로 Merkle tree를 제작
    3. Merkle tree의 루트 노드를 기준으로 어느 영역의 데이터가 깨졌는지를 판단
    4. 영역이 깨진 부분을 동기화
- 재해로 인해 데이터 센터 자체에서 문제가 발생하는 경우를 대비하기 위한 데이터 센터 다중화도 고려가 필요
