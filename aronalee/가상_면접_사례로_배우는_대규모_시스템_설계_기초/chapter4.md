# 요약

## 처리율 제한 장치

- DoS, 비용 절감, 서버 과부화 등 서버가 처리할 수 있는 처리량을 제한하는 장치

## 처리율 제한 장치 설계시 유의할 점

- 처리율 제한 장치의 위치
    - 클라이언트: 완벽한 제어는 불가능하나 간단함
    - 서버: 어느정도 제어가 가능함
    - 미들웨어: 클라이언트-서버 모델에서 중간에서 처리량을 필터링
- 우선순위가 무엇이냐
    - 사용하는 기술이 무엇인가
    - 마이크로서비스에 기반하고 있는가
    - 시간적으로 여유로운가

## 처리율 제한 알고리즘

### 토큰 버킷

- 사용처: Amazon
- 구성요소
    - Bucket: 토큰을 저장하는 크기가 제한된 공간
    - Refiller: 토큰을 주기적으로 버킷에 공급
- Refliller가 얼마나 토큰을 주느냐에 따라 처리량을 제한 가능함
- 구현은 쉽고 메모리도 적게 사용하나 버킷의 크기와 Refiller가 주는 주기의 조절이 어려움
- 로직
    1. Refiller는 버킷에 계속 토큰을 넣어준다.
    2. 처리 요청이 들어오면 버킷에서 토큰을 가져간다.
    3. 버킷에 토큰이 없다면 처리 요청을 거절한다.

### 누출 버킷

- 토큰 버킷에서 bucket을 queue로 구현
- 서버에서 주기적으로 요청을 가져와 처리하기에 처리 속도가 일정함
- 단시간에 몰리는 트래픽을 처리하기가 어려움
- 로직
    1. 요청이 들어오면 큐에 요청을 할당
    2. 서버는 큐에서 주기적으로 찾아서 요청 작업을 꺼내서 처리
    3. 큐가 찬 이후의 모든 요청이 거부

### 고정 윈도 카운터 알고리즘

- 시간 범위당 처리 가능한 처리 가능한 양을 정의
- 타임라인을 고정된 간격(윈도우)로 나누고 윈도우의 카운터 수로 처리량을 제한
- 순간 처리량이 높아질 수 있다
- 로직
    1. 요청이 접수
    2. 카운터 수가 최대여부인지를 확인
    3. 카운터 수가 최대이면 요청을 거부, 아니면 카운터를 올리고 요청을 접수

### 이동 윈도 로깅 알고리즘

- Timestamp를 이용한 처리량 제한 알고리즘
- 주로 Redis의 sortedset을 이용
- 순간 처리량이 높아지지 않는다
- 거부된 요청도 메모리에 쌓기에 메모리가 다량으로 사용됨
- 로직
	1. 요청이 들어오면 timestamp로 로그에 기록
	2. 로그에서 요청들어온 시간-처리제한시간 의 범위에 포함되지 않는 로그들을 제거
	3. 제거된 후에 로그의 수가 임계값인지를 확인

### 이동 윈도 카운터 알고리즘

- 고정 윈도 카운터 + 이동 윈도 로깅
- 요청 시점 기준으로 아래의 수식을 기반으로 요청 개수를 계산해 처리 여부를 결정
  - 요청 시점: n
  - 요청 시점이 속한 분에 속한 요청수: k
    - ex: 1시 1분 12초에 요청 => 1시 1분 ~1시 1분 12초까지
  - 직전 시점동안 들어온 요청수: l
    - ex: 1시 1분 12초에 요청 => 1시 0분 12초 ~ 1시 1분 12초
  - k와 l이 1분간 얼마나 비중을 차지하는지로 계산
    - ex: 1시 1분 12초에 들어온 요청 => k+l*(12/60)
- 이전 시간의 처리량을 기준으로 현 시점에 처리를 결정함
- 이전 시간의 처리량을 기반으로 이후의 처리량을 예상하기에 추정치 계산히 느슨함

### 카운터 관리

- 발단: 카운터를 사용하는 알고리즘은 카운터를 어떻게 관리해야 할까
- 책의 제한: redis를 이용한 카운터 관리
  - INCR: 메모리에 저장된 카운터 +1 명령어
  - EXPIRE: 카운터의 타임아웃 시간 설정

## 상세 설계시 주의점

- 처리율 제한 규칙을 어떻게 할 것이냐(분당 5회이상 로그인 금지 등)
- 처리율을 초과하는 요청에 대한 반환 방법
  - 클라이언트에게 처리율로 인해 요청이 거부되었음을 알려줄 것이냐
  - 알려준다면 어떤 방식으로 알려줄 것이냐
    - ex: 클라이언트에게 남은 처리양을 알려주어 클라이언트에서 요청을 거부시킬 것이냐
  - 큐에 담아서 일시적으로 요청을 대기시킬 것이냐

### 다중서버, 병렬 스레드 환경에서의 설계시 주의점

- race condition: 카운터 종류 알고리즘을 쓸 때 카운터 업데이터에서 race condition이 발생
  - 해결책: locking, sorted set
- 동기화 이슈: 처리율 제한 장치가 여러개가 존재할 경우 클라이언트가 요청할 때 이전 요청과 다른 처리율 제한 장치에 요청을 보내면 
  - 해결책: sticky session, redis

### 성능 최적화 문제

- 상황: 국내가 아닌 해외에서도 접속이 들어오는 경우
  - 해외서 들어오는 사용자는 물리적 거리 때문에 국내 사용자보다 레이턴시가 길어 처리 순서 늦게 배정받는 문제가 발생할 수 있음.
- 해결: CDN으로 물리적 거리의 제약을 감소
  - 단 CDN 사용 시 데이터 일관성이 준수되어야 함

